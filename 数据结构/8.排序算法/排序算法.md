# 排序算法

## 简单排序

- 冒泡排序
对未排序的各元素从头到尾依次比较相邻两个元素的大小关系
比较复杂度：
第一次循环有n-1次比较，第二次循环有n-2次比较...直到最后一趟进行了1次比较
(n - 1) + (n - 2) + ... + 1 = n*(n-1)/2
O(n^2/2 - n/2) = O(n^2)
交换复杂度：
如果有两次比较才需要交换一次的话，次数为：n*(n-1)/4
O(n^2/4 - n/4) = O(n^2)
是否稳定：是。因为当两个元素相等时不会进行交换，所以相同元素的前后顺序没有改变

- 选择排序
选定第一个索引位置，然后和后面元素依次比较，后面的小于前面的则交换位置
比较复杂度还是与冒泡排序一样
交换复杂度：
选择排序每次最多只交换1次，一共遍历n次，复杂度O(n^2)
是否稳定：否。在一次选择中，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相同的元素的后面，那么在交换后相同元素的前后顺序就被改变了

- 插入排序
相对于选择排序和冒泡排序，效率更高，因为比较次数更少。
插入排序的核心是局部有序
比较复杂度：
第一次循环最多1次，第二次循环最多2次
因此插入排序最多次数：(n - 1) + (n - 2) + ... + 1 = n*(n-1)/2
所以平均次数要除以2，n*(n-1)/4，相比与选择排序，比较次数少了一半
是否稳定：是。因为无论要插入的元素比这两个相同元素大或者小，都不会影响这两个相同元素的前后顺序

## 高级排序

- 希尔排序
希尔排序是插入排序的高效改进版，效率比插入排序要更快。
希尔排序原稿里的增量是N/2，即n=100的数组，增量间隔为：50,25,12,6,3,1
希尔排序的效率跟增量有很大关系，所以要证明它的效率很难。
希尔排序在最坏的情况下时间复杂度也是O(N^2)，一般情况下是O(nlogn)
是否稳定：否。当相同的元素被分在不同的子数组中时，可能会在各自的排序中移动，所以会改变原来的两相同元素的前后顺序

- 快速排序
可以说是目前所有排序中，相对来说最快的一种排序算法，最重要的思想是：分而治之。
可以看成是冒泡排序的升级版：冒泡排序需要经过多次变换，才能在一次循环中将最大值放在正确位置
而快速排序可以在一次循环中(其实是递归调用)，找出某个元素的正确位置，且该元素之后不需要任何移动。
枢纽的选择：left = 0, right = length - 1, center = (left + right) / 2
从上面三个指针指向的值中选取中位数作为枢纽。
快速排序的平均效率是 O(N*logN)，最坏情况时间复杂度是 O(n^2)（每次取到的基准元素都是数组中最小/最大的，这种情况就相当于冒泡了）
是否稳定：否。当枢纽元素和某相同元素之一的元素进行交换时，相同元素的前后顺序会被改变

- 归并排序
也采用分而治之的思想，将一个数组反复二分为两个小数组，直到每个数组只有一个元素
然后从最小数组开始，两两按大小顺序合并，直到并为原始数组大小
归并排序的时间复杂度：O(nlogn)
是否稳定：是。因为在短数组进行合并时，依然会把处在前面序列的元素保存在结果序列的前面，不会改变相同元素的前后顺序
