# 继承方式

## 原型链继承

利用原型链让一个引用类型继承另一个引用类型的属性和方法
即将子类的原型赋值给父类的实例

问题一：子类的实例会共享定义在父类构造函数中的引用类型值属性；
问题二：在创建子类的实例时，无法向父类的构造函数传递参数(但是在更改子类原型对象时可以)。

## 构造函数继承

在子类构造函数的内部调用父类构造函数
通过call()或apply()方法在特定环境中执行代码的对象

与原型链继承相比，构造函数继承很大的优势就是可以在子类构造函数中向父类构造函数传递参数

问题一：不能继承父类原型上的属性和方法；
问题二：所以导致父类的方法都得在构造函数中定义，函数无法复用。

## 组合继承

将原型链继承和构造函数继承组合到一起
使用原型链继承实现对原型属性和方法的继承，而通过构造函数继承来实现对实例属性的继承

组合继承是javascript中最常用的继承方式，但仍有不足：
不足：无论什么情况下，都会调用两次父类构造函数：一次是在创建子类原型时，一次是在子类构造函数内部。

## 原型式继承

借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。

function object (o) {
  function F() {}
  F.prototype = o;
  return new F();
}
先创建了一个临时性的构造函数，再将传入的对象作为这个构造函数的原型，最后返回一个新实例

在ES5 中，新增了Object.create()方法来规范原型式继承：
该方法接收两个参数：一个作为新原型的对象，一个作为新对象定义额外属性的对象(可选)
若只传入一个参数，该Object.create()与上面的object()方法行为相同

问题：与原型链继承一样，每个实例都会共享引用类型值的属性。

## 寄生式继承

与上面的原型式继承有着相同的思想
创建一个仅用于封装继承过程的函数，该函数在内部以某种方式增强对象，最后返回该对象

function createAnother (original) {
  var clone = Object.create(original);
  clone....
  return clone;
}

问题：与构造函数继承一样，无法做到代码复用而提高效率。

## 寄生组合式继承

寄生组合式继承不必为了指定子类的原型而调用父类的构造函数，我们只需要父类原型的一个副本。
其实就是使用寄生式继承来继承父类原型，然后再将结果指定给子类原型。

寄生组合式继承的高效率体现在它只调用了一次父类构造函数
该方式是最理想的继承方式

## ES6 的 extends 继承

es6的继承主要是 class 的继承，class 之间通过使用 extends 关键字实现继承
实际上在 class 中继承的本质依旧是原型对象

class Father{...}
class Son extends Father{...}

class 和 ES5 继承的区别：

- class 必须使用 new 来操作，而 ES5 的构造函数不用 new 也可以正常执行
- class 不存在变量提升，必须先定义 class 后才能实例化，不像 ES5 可将构造函数写在实例化之后(看例子 extends继承.html)
- ES5 继承通过 原型 和 构造函数 来实现，先创建子类，再实例化父类并添加到子类 this 中
- ES6 继承先创建父类，在实例化子类实例后通过调用super方法访问父类后才会得到子类自己的 this
