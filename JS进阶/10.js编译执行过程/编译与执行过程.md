# 编译与执行过程

## 编译阶段

编译阶段分为 词法分析、 语法分析、 预编译三个阶段

1. 词法分析
将 字符流 转换为 词法单元流(token)，就像英文句子一个个单词独立翻译，举例：
var result = testNum1 - testNum2;
词法分析后：
NAME "result"  
EQUALS  
NAME "testNum1"  
MINUS  
NAME "testNum2"  
SEMICOLON

2. 语法分析
将上一步生成的 token 数据根据语法规则生成对应的 "抽象语法树"(Abstract Syntax Tree, AST)
JS 会对全部的脚本代码进行解析，通过jS引擎检查你的代码是否存在错误，如果有格式错误就会抛出一个错误
然后就可以通过 AST 生成字节码(Bytecode)，也就生成了计算机可执行的代码
如：var a=2; 抽象语法树转为一组机器指令，用来创建一个叫作 a 的变量(包括分配内存等)，并将值 2 储存在 a 中

3. 预编译过程(并非完全按顺序执行)
当JavaScript引擎解析脚本时，他会在预编译阶段对 所有声明的变量 和 函数 进行处理，**并且是先预声明变量，再预定义函数(也就是变量提升优先于函数提升)**
任何变量，如果变量未经声明就赋值，预编译就会将此变量归为全局对象所有

预编译解析函数过程：

1. 创建AO对象 Activation Object 【我们所说的作用域，也称为执行上下文】
2. 找 形参 和 变量 声明，并作为 AO 的属性名，值为undefined
3. 将实参的值和形参相统一
4. 在函数体里面找到函数声明，值赋予函数体

具体看 预编译例题

## 解释执行过程

在执行过程中，JS 引擎是严格按照作用域（scope）机制来执行的。
JS的变量和函数作用域是在定义是决定的，而不是执行时决定的。且变量作用域在函数体内有效，无块作用域(let、const除外)

JS 引擎通过作用域链(scope chain)把多个嵌套的作用域串联在一起，并通过这个链条查找变量的值
JS 解释器按着这个链条进行快速查找，直到找到全局对象global object为止。如果没有找到值，则报错 XX is not defined

当解析执行完一个函数作用域后，该 AO 对象销毁
只有在页面关闭后，GO 对象才销毁

如果函数引用了外部变量的值，则JavaScript引擎会为该函数创建一个闭包体(closure)
它不会在执行完毕后就被JavaScript引擎当做垃圾进行回收，只有当闭包体的外部引用被全部设置为null值时，该闭包才会被回收
