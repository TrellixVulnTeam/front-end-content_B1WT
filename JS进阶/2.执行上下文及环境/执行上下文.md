# 执行上下文

javascript运行的代码环境有三种：

- 全局代码：代码默认运行的环境，最先会进入到全局环境中

- 函数代码：在函数的局部环境中运行的代码

- Eval代码：在Eval()函数中运行的代码

全局上下文是最外围的一个执行环境，web浏览器中被认为是window对象，在初始化代码时会先进入全局上下文中，然后全局上下文进栈(进入执行环境栈执行)
每当一个函数被调用时就会为该函数创建一个执行上下文，每个函数都有自己的执行上下文

## 执行环境栈

因为js是单线程，任务都为同步任务的情况下某一时间只能执行一个任务，所以会把代码中所有的执行上下文推入执行环境栈(ECStack)内等待被执行。

function f1() {
  var f1Context = 'f1 context';
  function f2() {
    var f2Context = 'f2 context';
    function f3() {
      var f3Context = 'f3 context';
      console.log(f3Context);
    }
    f3();
    console.log(f2Context);
  }
  f2();
  console.log(f1Context);
}
f1();

 全局上下文拥有f1()，f1()的上下文中有变量f1Context和f2()，f2()的上下文有变量f2Context和f3()，f3()上下文有变量f3Context。

执行一段代码首先会进入全局上下文中，并将其压入ECS中，执行f1()会为其创建执行上下文压入栈顶，f1()中有f2()，再为f2()创建f2()的执行上下文；
依次，最终全局上下文被压入到栈底，f3()的执行上下文在栈顶，函数执行完后，ECS就会弹出其上下文，f3()上下文弹出后，f2()上下文来到栈顶，开始执行f2()；
依次，最后ECS中只剩下全局上下文，它等到应用程序退出，例如浏览器关闭时销毁。

当函数执行完后它的执行上下文就会从执行环境栈中弹出，并且函数中变量对象随之销毁。

## 变量对象/活动对象

- 变量对象：创建执行上下文时与之关联的会有一个变量对象，该上下文中的所有变量和函数全都保存在这个对象中。

- 活动对象：当某一个函数执行时该函数上下文中的变量对象称为活动对象。

执行上下文的创建阶段(函数被调用，但是还未执行函数中的代码)：

1. 创建arguments，确定该arguments对象的属性和属性值；
   扫描函数声明，每扫描到一个函数就会在变量对象中用函数名创建一个指针，指向该函数的内存地址，若函数名已存在，则会被新的引用覆盖；
   扫描变量申明，每扫描到一个变量就会用变量名作为属性名，其值初始化为undefined，若变量名已经存在，则直接跳过继续扫描。

2. 建立作用域链

3. 确定this的值

执行上下文的执行阶段：变量赋值，函数引用，执行代码

执行上下文为一个对象，包含变量对象，作用域链和this
executionContextObj = {  
  variableObject: { // 函数中的arguments对象, 参数, 量以及函数声明 },  
  scopeChain: { // variableObject 以及所有父执行上variableObject },  
  this: {}  
}

具体例子看html文件
