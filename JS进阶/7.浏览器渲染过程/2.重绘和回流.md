# 页面的重绘(repaint) 和 回流(reflow)

- 重绘(repaint): 渲染树节点发生改变，但不影响该节点在页面当中的空间位置及大小，渲染树得重新渲染页面
比如更换个背景颜色或字体颜色等
**重绘只跟渲染树有关，DOM树不会变化**

- 回流(reflow): 当渲染树节点发生改变，影响了节点的几何属性，导致节点位置发生变化，此时触发浏览器回流
**回流跟渲染树和DOM树有关**
页面布局发生变化，DOM树结构发生变化，要重新构建DOM树。DOM树构建完，渲染树也会随之对页面进行再次渲染
**回流必将引起重绘，而重绘不一定会引起回流**

## 引起回流的属性

1. 添加或者删除可见的DOM元素；
2. 元素位置改变————display、float、position、overflow等等；
3. 元素尺寸改变————内边距、外边距、边框、宽度和高度
4. 内容改变————比如文本改变或者图片大小改变而引起的计算值宽度和高度改变；
5. 页面渲染初始化————这样的回流无法避免；
6. 浏览器窗口尺寸改变————resize事件发生时；
7. 访问 DOM 方法，如 offsetTop、offsetLeft、 offsetWidth、scrollTop、scrollLeft、clientTop、clientLeft等。这些值需要通过即时计算得到，因此浏览器为了获取这些值，也会进行回流
**display: none 会引起回流和重绘，visibility: hidden 只会引起重绘**

## 如何减少或避免回流

Reflow 的成本比 Repaint 的成本高得多的多
在一些高性能的电脑上也许还没什么，但是如果 Reflow 发生在手机上，那么这个过程是延慢加载和耗电的

1. DOM的增删行为：
如果要加多个子元素，最好使用documentfragment，或者用 cloneNode

2. 将多次改变样式的操作合并成一次
不要一条一条修改 dom 样式，最好将这些属性定义在一个class中，然后修改className，这样只用引起一次回流

3. 最好使用 transform 来代替 top/left 移动元素
因为 transform 只会改变图层的组合，不会改变元素本身的位置，因此不会引起页面的回流和重绘。而 top/left 会引起回流和重绘

4. 使用 display:none 来操作元素
若要对一个元素进行复杂操作，可以先用 display:none 隐藏它，操作完后再显示，这样只会触发两次回流

5. 使用 visibility 代替 display:none
因为前者只会引起重绘，后者会引发回流（改变了布局）
