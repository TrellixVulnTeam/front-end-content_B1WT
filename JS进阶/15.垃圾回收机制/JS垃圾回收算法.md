# JS 的垃圾回收机制

在某些变量（例如局部变量）在不参与运行时，就需要系统回收被占用的内存空间

## 垃圾回收方式

垃圾回收有两种方法：标记清除、引用计数

### 引用计数

引用计数是不太常用的垃圾回收方式(IE)

它的原理是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是 1
相反，如果对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减 1
垃圾回收器下次再运行时，它就会释放那些引用次数为 0 的值所占的内存
**引用计数最大的问题是：循环引用**

```javascript
function fn() {
  let obj1 = {};
  let obj2 = {};
  obj1.a = obj2;
  obj2.a = obj1;
}
```

向上面这样相互引用时，obj1 和 obj2 通过各自的属性相互引用，使得引用次数都是 2
函数执行完成之后，obj1 和 obj2 还将会继续存在，因为他们的引用次数永远不会是 0
这样大量的相互引用就会导致内存泄露

解决方法：手动清除
obj1.a = null;
obj2.a = null;

### 标记清除

这是 js 中最常用的垃圾回收方式(google chrome)

它的原理是当变量进入执行环境时，就标记这个变量为“进入环境”；当变量离开环境时，则将其标记为“离开环境”
然后垃圾收集器会保留环境中的变量和被环境中变量引用的变量（其实就是闭包），定时循环释放离开环境的变量的内存
大多现代浏览器都采取这个策略进行垃圾收集，它们之间的区别在于每个浏览器之间的垃圾收集器回收间隔时间不同

标记清除缺点：在清除后对象的内存位置是不变的，所以导致空闲的内存地址不连续，出现了内存碎片
