# 浏览器垃圾回收机制

## 栈的回收机制

栈用来在函数执行时存储保存执行上下文环境，我们一般也称调用栈
基本类型的变量，引用类型的引用地址等都保存在栈中。当前函数执行时进行入栈，执行完毕进行出栈

栈的回收方式是通过一个记录当前执行状态的指针(称为 ESP)，它指向活动栈
函数执行完毕，ESP 下移到下一节点，摧毁当前函数的执行上下文

## 堆的回收机制

对象的值等一些大数据都保存在堆中

堆是通过 JS 的垃圾回收器(GC)进行回收，回收方式是 标记清除法 或 引用计数法(不常用)

### 堆的垃圾回收

V8引擎对堆的数据分为 临时对象 和 长久对象

- 临时对象：生命周期很短，如函数内部声明的变量。当函数执行结束时，作用域中定义的变量就会被销毁。这类对象应该快速回收
- 长久对象：生命周期很长，如全局的 window、DOM、Web API 等等。长久对象可以慢点再回收

V8引擎将他们分别放入 新生代区域 和 老生代区域, 让副垃圾回收站负责回收新生代区域的垃圾, 让主垃圾回收站负责回收老生代区域的垃圾

- 副垃圾回收站将新生代区域平分为 对象区 和 空闲区
新加入的对象都被放入对象区，当对象区内存存满时启动垃圾回收，遍历对象进行垃圾标记，标记完后将存活的对象按顺序复制到空闲区
复制完成后，对象区 和 空闲区进行对调（防止产生大量不连续的内存碎片），将空闲区存活的对象放入对象区中，垃圾回收完成
因为副垃圾回收器操作频繁，所以为了效率一般新生代区域的存储空间设置的很小
经过两次垃圾回收依然存活的对象就会被移动到老生代区域

- 主垃圾回收站
老生代区域的空间大，使用 标记-清除 的算法执行垃圾回收
从一组根元素开始, 递归标记这组根元素。在标记过程中, 能到达的元素称为活动对象, 没到达的元素判断为垃圾
标记完后，先将所有存活的对象向一端移动，然后直接清理掉另一端的内存（为了防止产生大量不连续的内存碎片）
