# TCP 协议三次握手和四次挥手

## 三次握手

- 第一次握手：
向服务器发出连接请求报文，这时报文首部中的同部位 SYN = 1，同时选择一个初始序列号seq = x，
客户端进程进入了SYN-SENT（同步发送）状态,等待服务器确认；

- 第二次握手：
服务器收到 SYN 包后，如果同意连接，则发出确认报文 ACK = 1，SYN = 1，确认序列号 ack = x + 1，(也就是将收到的初始序列号+1)
同时也要为自己初始化一个序列号 seq = y，此时服务器进程进入了 SYN-RCVD（同步接收）状态；

- 第三次握手：
客户端收到服务器的 SYN + ACK 包，要向服务器给出确认。确认报文的 ACK = 1，ack = y + 1，自己的序列号 seq = x + 1，
此时，TCP 连接建立，客户端进入 ESTABLISHED （已建立连接）状态。

完成三次握手，客户端与服务器开始传送数据

注：
seq:"sequance" 序列号；
ACK:"acknowledge" 确认序列号有效；
SYN:"synchronize" 请求同步标志；
ACK:"acknowledge" 确认标志；
FIN:"Finally" 结束标志。

### 为什么不是两次握手

想象如下场景：
客户端发送一个连接请求 A，但因为网络原因造成了超时，这时超时重传机制再次发送一个连接请求 B。此时请求顺利到达服务端，服务端应答完就建立了请求，然后接收数据后释放了连接
假设这时候连接请求 A 在两端关闭后终于抵达服务端，此时服务端会认为客户端又需要建立 TCP 连接
从而应答了该请求并进入 ESTABLISHED 状态。但是客户端其实是 CLOSED 的状态，那么就会导致服务端一直等待，造成资源的浪费

### 哪次握手最容易受到攻击

第二次握手最容易受到攻击，即 SYN溢出攻击：
如果客户端恶意伪造出大量第一次的 SYN 报文，服务端就会依次消耗掉很多资源来进行确认，服务端会连续多次进行第二次握手确认后才认定失败
那么短时间内有大量 SYN 报文发向服务端，服务端资源可能被耗尽，就可能导致正常的客户端得不到响应而失败

### 建立连接后客户端出现故障怎么办

服务端有一个保活计时器，服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为 2 小时
若两小时还没有收到客户端的任何数据，服务器就会每隔 75 秒发送一个探测报文段，若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，关闭连接

## 四次挥手

建立一个连接需要三次握手，而终止一个连接要经过四次握手，这是由 TCP 的半关闭（half-close）造成的

- 第一次挥手：
客户端进程发出连接释放报文，并且停止发送数据。
释放数据报文首部 FIN=1，其序列号为 seq = u（等于前面已经传送过来的数据的最后一个字节的序号加1）
此时，客户端进入 FIN-WAIT-1（终止等待1）状态。

- 第二次挥手：
服务器收到连接释放报文，发出确认报文，ACK = 1，ack = u + 1，并且带上自己的序列号 seq = v
此时，服务端就进入了 CLOSE-WAIT（关闭等待）状态。

这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。
客户端收到服务器的确认请求后，客户端就进入 FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文

- 第三次挥手：
服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN = 1，ack = u + 1
由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为 seq = w，此时，服务器就进入了 LAST-ACK（最后确认）状态，等待客户端的确认

- 第四次挥手：
客户端收到服务器的连接释放报文后，必须发出确认，ACK = 1，ack = w + 1
而自己的序列号是 seq = u + 1，此时，客户端就进入了 TIME-WAIT（时间等待）状态。

此时 TCP 连接还没有释放，必须经过 2MSL（最长报文段寿命）的时间后，当客户端撤销相应的 TCB 后，才进入 CLOSED 状态。
服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态。同样，撤销 TCB 后，就结束了这次的 TCP 连接。
由此可以得出，服务器结束 TCP 连接的时间要比客户端早一些

由于 TCP 连接是全双工的，因此每个方向都必须单独进行关闭
这个原则是当一方完成它的数据发送任务后就能发送一个 FIN 来终止这个方向的连接
收到一个 FIN 只意味着这一方向上没有数据流动，一个 TCP 连接在收到一个 FIN 后仍能发送数据
首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭
**Connection: keep-alive 能够保证TCP通道建立完成后，可以不关闭，HTTP 1.1 版本后默认开启**

### 为什么需要 4 次挥手

挥手阶段中服务端的 ACK 和 FIN 数据包不能合为一次
因为挥手阶段的流程为客户端发送 FIN 数据包表示自己发完了，服务端立即回复 ACK 数据包表示自己知道了
此时客户端到服务端的连接已经释放了，客户端不会再主动发送数据了，但服务端还可以继续向客户端发送数据
等到服务端也完成了数据发送，才会发送 FIN，这时客户端回复 ACK，就可以结束通信了
