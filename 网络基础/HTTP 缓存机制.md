# HTTP 缓存

缓存是一种保存资源副本并在下次请求时直接使用该副本的技术

当 web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载
这样带来的好处是缓解服务器端压力，提升性能(获取资源的耗时更短了)。对于网站来说，缓存是达到高性能的重要组成部分

缓存可分为两种：私有缓存 和 共享缓存
私有缓存只能用于单独用户(在响应头中将 Cache-Control 设置为 private)；
共享缓存能够被多个用户使用((在响应头中将 Cache-Control 设置为 public))；

HTTP 通过缓存将服务器资源的副本保留一段时间，这段时间称为新鲜度限值。这在一段时间内请求相同资源不会再通过服务器
HTTP 协议中 Cache-Control：Max-Age 和 Expires 可以用来设置新鲜度的限值

## 强缓存

强缓存可采用响应头中的 Cache-Control 和 Expires 两个字段进行控制的

其中 Expires 是 HTTP1.0 中定义的，它指定了一个绝对的过期时期；而 Cache-Control 是 HTTP1.1 时出现的缓存控制字段
Cache-Control: max-age 定义了客户端控制资源的有效期(单位是秒)
Cache-Control: s-maxage 定义了代理服务器（比如 cache CDN）的缓存的有效时间，并只对 public 缓存有效。如果 s-maxage 未过期，则向代理服务器请求其缓存内容
Cache-Control: public，表示它既可以被浏览器缓存，也可以被代理服务器缓存；如果设置了 private，则该资源只能被浏览器缓存
Cache-Control: no-cache 表示每一次请求都不会再去询问浏览器的缓存情况，而是直接向服务端确认该资源是否过期(走协商缓存)
Cache-Control: no-store 表示不使用任何缓存策略，直接向服务端发送请求、并下载完整的响应

两个字段同时存在时 Cache-Control 的优先级会更高一点
因为 expires 是有问题的，它最大的问题在于对“本地时间”的依赖。若服务端和客户端的时间设置差距很大，expires 将无法达到我们的预期

当客户端收到服务器发来的响应时，会通过对比本地时间和服务器返回的生存时间来检测缓存是否可用。
如果缓存没有超出它的生存时间，客户端就会直接采用本地的缓存，且返回状态码 200(from memory cache) 或 200(from disk cache)
先从内存中查找，如果有，直接加载；如果没有，从磁盘中读取，直接加载
如果生存日期已经过了，这个缓存也就宣告失效，接着客户端将与服务器进行协商缓存来验证这个缓存是否需要更新

## 协商缓存

协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新下载最新的资源，还是从本地获取缓存的资源
如果服务端提示缓存资源未改动，资源会被重定向到浏览器缓存，这种情况下网络请求对应的状态码是 304

当客户端再次请求该资源的时候，会在其请求头上附带上 If-Modified-Since 字段，值就是第一次获取请求资源时响应头中返回的 Last-Modified 值(该值表示资源文件最后更新的时间，客户端第一次收到该值会将该值保存到缓存)
如果资源未过期，命中缓存，服务器就直接返回 304 状态码，资源会被重定向到浏览器缓存；
否则，服务器重新发送响应资源。从而保证资源的有效性。

服务器返回响应头的 Etag 标识服务器资源的校验码（例如文件的 hash 值），发送到客户端浏览器，浏览器收到后把资源文件缓存起来并且缓存 Etag 值(该值记录的是一个标识，这个标识根据资源文件更新而生成，每次文件更新都会重新生成一个 Etag)
Etag 由响应头的 Last-Modified 与 Content-Length 表示为十六进制组合而成
当浏览器再次请求此资源文件时，会在请求头 If-None-Match 字段带上缓存的 Etag 值。
服务器收到请求后，把请求头中 If-None-Match 字段值与服务器端资源文件的验证码进行对比，如果匹配成功直接返回 304 状态码，浏览器就从本地缓存取资源文件；
如果不匹配，服务器会把新的验证码放在请求头的 Etag 字段中，并且以 200 状态码返回最新的资源信息。

两个字段同时存在时，Etag 的优先级更高
因为1. 如果修改文件的速度过快时(比如只花了100ms)，由于 If-Modified-Since 只能检查到以秒为单位的时间差，所以它无法感知这次改动
    2. 如果在本地打开缓存文件，即使不进行修改也会造成 Last-Modified 被修改，导致服务端发送相同的资源

Etag 的问题：相同的资源，在两台服务器产生的 Etag 是不相同的
所以对于使用服务器集群来处理请求的网站来说，在这种情况下使用 Etag 来处理缓存，反而会有更大的开销

## 没有设置缓存策略

如果浏览器没有设置缓存策略，浏览器会采用一个算法
通常会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间

## 访问缓存优先级

1. 先在内存中查找,如果有则直接加载
2. 如果内存中不存在,则在硬盘中查找,如果有直接加载
3. 如果硬盘中也没有,那么就进行网络请求
4. 请求获取的资源缓存到硬盘和内存

## 缓存位置

1. Service Worker
Service Worker 是运行在浏览器背后的独立线程，基于 Web Worker 实现，所以不会阻塞当前 JS 线程
如果网站注册了 Service Worker 就可以拦截当前网站所有请求并进行判断，需要向服务器发起请求的就转给服务器，可以直接使用缓存的就直接返回缓存不再转给服务器
**使用 Service Worker 时传输协议必须是 https，因为涉及到请求拦截，所以要通过 https 协议来保障安全**
注册完 Service Worker 后监听 install 事件，就拿到了需要缓存的文件
通过监听 serviceWorker 的 fetch 事件即可实现拦截全站的请求，因为任何对网络资源的请求都会触发该事件

2. Memory Cache
存储在内存中的缓存，再次访问时不会请求服务器。读取速度比硬盘快得多，但内存容量小，且持续时间短，一旦关闭页面内存中的缓存就被释放了
**内存中有一块重要的资源是 preloader 相关指令下载的资源**

3. Disk Cache
存储在硬盘中的缓存，再次访问时不会请求服务器。读取速度慢，但容量大，持续时间长，页面关闭后缓存也不会释放
绝大部分的缓存都来自 Disk Cache

4. Push Cache
服务端推送的缓存(http2.0)，一旦 TCP 连接关闭，Push Cache 就会被释放
