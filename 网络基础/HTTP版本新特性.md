# HTTP 版本新特性

## HTTP1.1 新特性

1. 长连接
在 HTTP1.1 中的 connection 默认开启长连接 keep-alive，在一个 TCP 连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗
2. host （域名 + 端口号）
HTTP 1.1 的请求消息和响应消息都支持 host 域用来传递主机名，且请求消息中如果没有 host 域会报告一个错误（400）
3. 缓存处理
HTTP1.1 引入了更多缓存策略，例如 Etag / Cache-Control / If-Match / If-None-Match 等更多可供选择的缓存头来控制缓存策略

## HTTP2.0 新特性

1.多路复用

- HTTP1.1 中浏览器限制了同一时间同一域名下建立 TCP 连接的数量（Chrome 下一般是六个）
当在请求很多资源的时候，由于线程阻塞当浏览器达到最大请求数量时，剩余的资源需等待当前的六个请求完成后才能发起请求(这就是人们常说的队头阻塞)

- HTTP2.0 引入了多路复用的技术，这个技术可以只通过一个 TCP 连接就可以并行传输所有的请求数据
多路复用可以绕过浏览器限制同一管道的请求数量的问题，进而提高了网页的性能

原理：http2.0 在应用层（HTTP）和传输层（TCP）之间增加一个二进制分帧层
客户端和服务端进行传输时,数据会先经过二进制分帧层处理，转化为一个个带有标识的帧，多个帧组成了流
服务端可通过帧中的标识知道属于哪个请求

HTTP2.0 解决了 HTTP1.1 管线化队头阻塞的问题：
**HTTP1.1 多个请求是在同一个 TCP 管道中的，请求组成一个队列发出去，服务器接收到这个队列之后会依次响应，一旦前面的请求阻塞，后面的请求就会无法响应**
**HTTP2.0 多个请求可同时在一个连接上并行执行。当某个请求出现阻塞时，不会影响到其它请求的正常执行**

HTTP2.0 并没有彻底解决 TCP 队头阻塞的问题：
**HTTP2.0 多个请求是在同一个TCP管道中的，当出现丢包时，由于 TCP 的"丢包重传"机制，整个 TCP 都要开始等待重传，一旦丢包就会等待重新发包，阻塞后续传输**

2.服务器推送
例如向服务器发送一个html文件的请求，在客户端收到html文件的同时，服务器会将相关的资源主动发送给客户端，比如 css/js/img...
当客户端再次尝试获取这些文件的请求时，直接从缓存中获取就好，不用再发请求了
这样就避免了发送多次 http 请求，能够有效的优化性能和速度(客户端也有权利选择是否接收,可以通过发送 RST_STREAM 标识符来拒收)

3.报头压缩
http 的 header 带有大量信息，而且每次都要重复发送，http2.0 将 header 进行了压缩，以减小 header 大小
通信双方共同维护一份静态表和一份动态表(二表合起来充当字典的角色)，每次请求时发送方根据字典内容进行编码压缩消息头部，接收方根据字典进行解码，并且根据指令来判断是否需要更新动态表
当下次请求时,对于已经记录的字段就不再发送，只需要发送其对应的索引。每个新的字段要么被追加到当前表的末尾，要么替换表中原来的值
为了限制解码器端的内存需求，动态表的大小受到限制。动态表的大小 = (每个 Header 字节数的和 + 32) * 键值对个数

4.二进制传输
HTTP2.0 将请求和响应数据分割为更小的帧，并且它们采用二进制编码
它把原来的"Header + Body"的消息"打散"为数个小片的二进制"帧",用"HEADERS"帧存放头数据、"DATA"帧存放实体数据
HTTP2.0 数据分帧后 "Header+Body" 的报文结构就完全消失了，协议看到的只是一个个的"碎片"
多个帧之间可以乱序发送，根据帧头部的流标识可以重新组装

## HTTP3.0

HTTP3.0 是基于 UDP 协议的 "QUIC" 协议实现的

QUIC 在 UDP 的基础之上增加了一层来保证数据可靠性传输。它提供了丢包重传、流量控制及其他一些 TCP 的特性
利用 QUIC 可以实现使用 0-RTT 建立连接，这意味着 QUIC 可以用最快的速度来发送和接收数据
多路复用，解决了 HTTP2.0 队头阻塞的问题，QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流
