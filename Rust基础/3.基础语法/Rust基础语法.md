# Rust 基础语法

## 变量与常量

声明变量使用 let 关键字，默认情况下变量不可变；若在变量前加 mut 关键字，则变量可变
声明常量使用 const 关键字，常量类型必须标注，且不可使用 mut。常量命名全用大写字母，单词之间用下划线分开

隐藏(shadowing) 可使用相同变量名声明新变量，新变量会隐藏旧的同名变量
let x = 1;
let x = x + 1; // 若不使用 let 关键字，则重新给非 mut 变量赋值会报错
let x = x * 2;
println!("{}", x); // 12

shadowing 与 mut 区别是：使用 let 声明的新变量类型可与之前不同，而赋值 mut 变量时类型必须与之前一致

## 数据类型

数据类型分为标量和复合，Rust 为静态编译语言，在编译时必须知道所有变量的类型

1. 标量类型代表一个单个值，标量类型分为四种：
整数类型：无小数部分(默认类型为 i32)。无符号整数以 u 开头，有符号整数以 i 开头；后面跟位数，如 u32 表示无符号32位整数
浮点类型：含小数部分(默认类型为 f64)。f32 为 32位单精度浮点数，f64 为 64位双精度浮点数
布尔类型：类型为 bool，值为 true 或 false
字符类型：类型为 char，值为单个字符，且要使用单引号

2. 复合类型可将多个值放入一个类型，复合类型分为两种：
元组(Tuple)：Tuple 的长度固定，且每个位置都对应一个类型，值用逗号分开
  let tup: (i32, f64, u8) = (500, 6.4, 1);
  println!("{}, {}, {}", tup.0, tup.1, tup.2);
  // 或用解构方法
  let (x, y, z) = tup;
  println!("{}, {}, {}", x, y, z);

数组(Array)：与元组不同，数组中元素类型必须相同，且长度也固定；与 Vector 不同，Vector 由标准库提供，且长度可变
  // 数组存储在栈内存中，数组类型表示为：[类型; 长度]
  let arr: [i32; 5] = [1, 2, 3, 4, 5];
  // 若数组每个元素都相同，可直接在中括号里指定初始值与长度并赋值
  let arr = [3; 5]; // [3, 3, 3, 3, 3];

## 函数

使用关键字 fn 来声明函数，命名时都为小写字母，单词之间用下划线分开
必须对函数的各参数进行类型声明，且需在 -> 后声明返回值类型。函数体中的最后一个表达式的值即为返回值
  fn main(x: i32, y: u32) -> i32 {
    x + y // 后面不能带";"，否则语句就没有返回值了,会报错
    // 等价于下面写法
    //return x + y
    //等价于下面写法,
    //return x + y;
  }
  println!("{}", main(5, 6)); // 11

## 注释

普通注释与 JS 一致
文档注释以 /// 开头；描述外层项以 //! 开头，通常用于 crate 根文件（src/lib.rs）或模块的根文件为 crate 或模块整体提供注释

```rust
//! # My Crate
//!
//! `my_crate` 是一个使得特定计算更方便的
//! 工具集合

/// 将给定的数字加一
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -> i32 {
    x + 1
}
```

## 控制流

if 表达式：判断内容必须返回 bool 类型，不会像 JS 那样强制转换。判断内容不加 ()，各分支代码必须加 {}
  if num < 5 {
    println!("Too small");
  } else {
    println!("Too big");
  }

loop 循环：一直执行，除非有 break 关键字
while 循环：每次执行循环体前都判断一次条件
for 循环遍历集合：
  let arr = [1, 2, 3, 4, 5];
  for element in arr.iter() {
    println!("{}", element);
  }

Range 范围: 由标准库提供，指定开始数字与结束数字，可生成它们之间的数(不包括结束数字)，Range 为一个迭代器
  for elem in (1..4).rev() { // rev 方法可反转 Range
      println!("{}", elem); // 3 2 1
  }
