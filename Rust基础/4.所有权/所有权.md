# 所有权

所有权是 Rust 独有的特性，让 Rust 无需 GC(垃圾回收器)就可保证内存安全
通过所有权系统管理内存，编译器在编译时会根据一系列规则进行检查。在运行时，所有权系统的任何功能都不会减慢程序运行速度

## stack 与 heap

所有存储在栈上的数据必须拥有已知的固定大小，而编译时大小位置或运行时大小可能发生变化的数据必须存在堆上
数据存入栈中比在堆上快得多，因为操作系统无需寻找存储新数据的空间，只需将数据压入栈顶

所有权的作用：
-跟踪代码的哪些部分正在使用堆中的哪些数据
-最小化堆上的重复数据量
-清理堆中未使用的数据以避免空间不足

## 所有权规则

1. 每个值都对应一个变量，该变量就是该值的所有者
2. 每个值只能有一个所有者
3. 当所有者超出作用域(scope)时，该值会被删除

```rust
let s = "hello"; // 变量 s 绑定了一个字符串字面值

let mut s = String::from("hello"); // 创建一个 String 类型
s.push_str(", world!"); // push_str() 在字符串后追加字面值
println!("{}", s); // 打印 `hello, world!`
```

String 类型的值可以修改，而字符串字面值无法修改
对于字符串字面值，在编译时就知道其内容，所以文本被直接硬编码进最终的可执行文件中
对于 String 类型，为了支持一个可变性，需要在堆上分配一块在编译时未知大小的内存来存放内容
  当调用 String::from 时，实现了在运行时向操作系统请求内存
  内存在拥有它的变量离开作用域后就被自动释放，Rust 在作用域结尾的 } 处自动调用 drop 函数来释放内存
  当一个堆内数据的变量离开作用域时，它对应的值也会被 drop 函数清理，除非该值的所有权转移到另一个变量上

## 变量与数据的交互方式

### 移动

```rust
let s1 = String::from("hello");
let s2 = s1;
println!("{}, world!", s1); // 此处会报错
```

当 s1 和 s2 离开作用域，他们都会释放相同的内存。这会导致二次释放（double free），产生内存安全性 bug
为了确保内存安全，当 s1 的值移动给了 s2 后，s1 就已经失效了，所以后面再使用 s1 就会报错

### 克隆

若想对堆上的 String 数据进行深拷贝，可使用 clone 方法

```rust
let s1 = String::from("hello");
let s2 = s1.clone();
println!("s1 = {}, s2 = {}", s1, s2); // 此时 s1 和 s2 都有效，不报错
```

clone 比较耗费资源，因为会将 s1 在栈上(指针)及堆上(字符串值)的数据都复制一份并赋值给 s2
因此若只针对栈上的数据，可以直接拷贝(copy)
let x = 5;
let y = x;

如下是一些可用 Copy 的类型：
· 所有整数类型，比如 u32
· 所有浮点数类型，比如 f64
· 布尔类型，true 和 false
· 字符类型，char
· 元组，当且仅当其包含的类型也都能 Copy 的时候。如 (i32, i32) 能 Copy，而 (i32, String) 不能

## 所有权与函数

1. 值作为参数传递给函数，将发生移动或复制。String 类型的值传递给函数时会发生移动，字符串字面值传递给函数时会发生复制
2. 函数在返回值的过程中同样会发生所有权的转移

## 引用和借用

引用: 允许你引用某些值而不取得其所有权
借用: 把引用作为函数参数的行为，借用的东西无法修改

引用和变量一样，默认都是不可变的，也可通过 mut 关键字创建一个可变引用
不可同时拥有一个可变引用和一个不可变引用，多个不可变引用是允许的
**注意：在特定作用域中的特定数据有且只有一个可变引用，好处在于可防止在编译时的数据竞争**

```rust
let mut s = String::from("hello");

let r1 = &mut s;
let r2 = &mut s; // 这里会报错，只能有一个可变引用
```

## 字符串切片(slice)

字符串切片是一种不持有所有权的数据类型，类型表示为 str
形式为: [开始索引..结束索引] 不包括结束索引。若开始索引从 0 开始时，则开始索引可省略；若结束索引取到最后时，结束索引可省略

let s = String::from("hello world");
let hello = &s[..5];
let world = &s[6..];
let whole = &s[..]; // 整个字符串的切片

字符串字面值是切片：
let s = "hello world"; // &str 是不可变引用，所以字符串字面值也不可变
**定义函数时使用字符串切片来代替字符串引用会使 API 更加通用**

### 数组切片

let a = [1, 2, 3, 4, 5];
let slice = &a[1..3];
